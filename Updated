#include <iostream>
#include <opencv2/opencv.hpp>

using namespace std;
using namespace cv;

int main() {
    // Load input image
    Mat image = imread("C:/Users/Rishi/OneDrive/Pictures/brain.png");

    // Resize image to a smaller size
    Size newSize(640, 480);
    resize(image, image, newSize);

    // Convert image to grayscale
    Mat grayImage;
    cvtColor(image, grayImage, COLOR_BGR2GRAY);

    // Apply top hat filter
    Mat kernel = getStructuringElement(MORPH_ELLIPSE, Size(15, 15));
    Mat topHat;
    morphologyEx(grayImage, topHat, MORPH_TOPHAT, kernel);

    // Blur image
    GaussianBlur(topHat, topHat, Size(5, 5), 0);

    // Apply thresholding for segmenting
    Mat thresholded;
    threshold(topHat, thresholded, 0, 255, THRESH_BINARY + THRESH_OTSU);

    // Compute distance transform
    thresholded.convertTo(thresholded, CV_8UC1);

    Mat dist;
    distanceTransform(thresholded, dist, DIST_L2, 3);

    // Find local maxima in distance transform
    Mat localMaxima;
    dilate(thresholded, localMaxima, Mat());
    compare(thresholded, localMaxima, localMaxima, CMP_EQ);
    localMaxima.convertTo(localMaxima, CV_8UC1);

    // Find markers for watershedding
    Mat markers;
    connectedComponents(localMaxima, markers);

    // Apply watershedding
    watershed(image, markers);

    // Display output
    Mat output = Mat::zeros(image.size(), CV_8UC3);
    for (int i = 0; i < markers.rows; i++) {
        for (int j = 0; j < markers.cols; j++) {
            int index = markers.at<int>(i, j);
            if (index == -1) {
                output.at<Vec3b>(i, j) = Vec3b(255, 255, 255);
            } else if (index == 1) {
                output.at<Vec3b>(i, j) = Vec3b(255, 255, 255);
            }
        }
    }
    imshow("Output", output);
    waitKey(0);

    return 0;
}
